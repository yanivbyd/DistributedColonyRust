---
alwaysApply: true
---

# my-rules.mdc

## CursorAI Rules

### Specification Workflow Rules
- Each spec begins when the **Human Author** requests CursorAI to generate a specification based on an explanation.
- Human Author comments written inline as `<<...>>` inside specs must be **integrated into the spec text** and then **removed** from the document once applied.
- **Spec Status: waiting answers**  
  CursorAI generates the initial version, including a **Clarifications** section at the top.
- The **Human Author** answers the questions and may add more details inside the Clarifications section.
- CursorAI integrates these answers and updates the spec status to **draft**.
- A ping-pong iteration continues until the **Human Author** explicitly approves the specification.
- CursorAI begins implementation **only** when the **Human Author** explicitly instructs it to do so.
- Every specification document contains **two sections**:
  1. **Spec Header** at the top, containing:  
     - Spec status  
     - Open questions for the **Human Author**  
     - If applicable: **Required Human Author decisions** (e.g., choice among design options)
  2. **Main specification**, limited to **150 lines or fewer**, unless explicitly permitted otherwise.
- When a spec presents multiple design options:
  - The recommended option’s title must end with **"(Recommended)"**.
  - Alternative options must include pros, cons, and a short motivation.
  - A **Human Author decision** is required to select the recommended option before proceeding.
  - After the **Human Author** approves the recommended option, alternatives are moved to an **Appendix**.
- Before creating a fix try to create failing a unit test that correspond to the bug (unless creating the unit test involves too many changes). Always ask permission before touching unit or integration tests.
- CursorAI must not invent or assume APIs, functions, modules, configurations, or behaviors that are not explicitly described or confirmed by the **Human Author**.  
  If any element is unclear or unspecified, CursorAI must request clarification rather than guessing.

### General Coding Rules
- Write simple, easy-to-read code.
- Avoid code repetition.
- Keep changes minimal and aligned with the prompt.
- Prioritize efficient yet readable code.
- Always build after changes and ensure zero errors or warnings.
- Do not ask for permission before applying changes; apply directly.
- Log errors using `log_error`.
- Do not run crates — only verify they build cleanly.
- Use **tokio** for parallelism; never use **Rayon**.
- Never clone large objects (e.g., `ColonyShard`).

### Code Architecture Rules
- High-level functions focus on business logic and orchestration.
- Low-level operations (TCP, serialization, file I/O, error handling) belong in helper utilities.
- Functions should read like clean, well-defined API calls rather than exposing implementation details.
- Extract repetitive or low-level logic into shared helper functions.

### Rust-Specific Rules
- Use `log!` for logging; avoid `crate::log!`.
- Prefer `.expect(...)` over custom logging macros like `log_expect`.
- Import commonly used types (e.g., `TcpStream`, `Request`) instead of using fully qualified paths.
- Import request types directly instead of `shared::be_api::Request`.
- Keep `main.rs` minimal; move colony/shard logic into appropriate modules.
- Resolve all compiler warnings.
- Pass RNG objects to helper functions; avoid unnecessary re-creation.
- Always use `shared::utils::new_random_generator()` for RNG creation.
- Do not use `SmallRng::from_entropy()` directly.
- Consolidate duplicate constants or logic into the `shared` crate.
- Avoid global counters or global mutable state.
- Include the **region** parameter when logging colony events in backend code.
- Do not use `[COORD]` or `[BE]` prefixes in logs.