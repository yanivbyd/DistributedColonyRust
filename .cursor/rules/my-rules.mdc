---
description: 
globs: 
alwaysApply: true
---
Write simple, easy-to-read code.
Avoid code repetition.
Keep changes minimal and aligned with the prompt.
Prioritize efficient yet readable code.
Always build after doing changes, make sure no errors or warnings.
Do not ask for changes, always apply without asking.
Logging error should be done via log_error.
Do not run the crates - only check if they build without errors/warnings.
Do not use Rayon, always use tokio for parallelism
Never clone large objects, such as ColonyShard

## Specification Workflow
- **Acknowledgment section location**: The "Acknowledgment" section must always be the **first section** in any specification file (placed immediately after the title)
- **NEVER implement before specification is acknowledged**: All feature specifications in `feature_specs/` directory must have an "Acknowledgment" section at the beginning
- **Check for acknowledgment**: Before implementing any feature from a spec file, verify that the "Acknowledgment" section shows the specification has been reviewed and approved AND marked as "Ready for implementation"
- **If not acknowledged**: Only work on the specification itself (updates, clarifications, etc.) - do NOT start implementation
- **After acknowledgment**: Proceed with implementation according to the specification
- **Recommended options in specs**: When a specification presents multiple options and one is recommended, indicate this in the section title by adding "(Recommended)" to the recommended option, e.g., "Option 1: Description (Recommended)". For each alternative option, clearly state the pros and cons compared to the recommended option, and explain the motivation for presenting that alternative option.
- Implementation alternatives should always be in the last section, once the leading option is approved we should remove move the alternatives to an appendix

## Code Architecture Guidelines
- **High-level functions** should focus on business logic and orchestration
- **Low-level details** (TCP connections, serialization, file I/O, error handling) should be abstracted into separate helper functions
- Functions should read like API calls, not implementation details
- Abstract low-level operations into reusable helper functions

## Rust-Specific Guidelines
- Use the log! macro for logging in Rust code instead of crate::log!
- Prefer using .expect over macros like log_expect for error handling
- Use imports to refer to types like TCPStream and Request rather than fully qualified names
- Import Request classes and refer to them by simple names instead of fully qualified shared::be_api::Request
- Main.rs should be thin and shard-related logic should be placed in shard utils or colony modules
- Always clean up compiler warnings in the code
- Prefer passing random number generator objects (rng) to helper functions and using the random range function consistently
- Always use `shared::utils::new_random_generator()` for random number generation, never use `SmallRng::from_entropy()` directly
- Place duplicate code and constants under the shared crate instead of copying code from one module to another
- Avoid using global counters or global state
- Include the region parameter when logging colony events in backend code
- Do not include the [COORD] or [BE] prefix in log lines